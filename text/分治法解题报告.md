# 0 总览
遍历法能解决70-80% 的二叉树的问题。分治法能解决99%。DP 算法离不开分治法的思想，他们之间有区别。

分治法可以归类到深度优先搜索算法中。

用深搜的题不好识别，往往是其它方法不行时，才想到深搜。

有三堂直播课讲深搜：分治法，排列组合，记忆化搜索（为DP做准备）。

独孤九剑——破枪式

碰到二叉树问题，就想想整棵树在该问题上的结果，和左右儿子在该问题上的结果之间的联系是什么。

二叉树考点剖析

- 二叉树上求值求路径  代表例题：http://www.lintcode.com/problem/subtree-with-maximum-average
- 二叉树结构变化  代表例题：http://www.lintcode.com/problem/invert-binary-tree
- 二叉查找树  代表例题：http://www.lintcode.com/problem/validate-binary-search-tree/

考点本质：基于树的深度优先搜索

# 1. 二叉树上求值，求路径
Maximum / Minimum / Average / Sum / Paths

596 · Minimum Subtree

https://www.lintcode.com/problem/596/

### 1. 用到了什么算法
分治法

### 2. 看到什么条件想到的算法
子树：树中的某一个节点及从该节点到叶子节点的所有节点组成的树
问题可以分解成，包括当前节点的子树，左子树，右子树，哪个树对应的和最小。

最小子树只有可能有三种情况，一个是在当前节点左边的子树，一个是在当前节点右边的子树，还有就是包括当前节点的树。
把最值，以及包括当前节点的和返回，避免全局变量打擂台。

###  3. 不同解法分别怎么做的
```python
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the root of binary tree
    @return: the root of the minimum subtree
    """
    def findSubtree(self, root):
        _, node, _ = self.helper(root)
        return node

    def helper(self, node):
        # 递归的出口
        if node is None:
            return float('inf'), None, 0

        # 无脑分治
        left_min, left_min_sub, left_sum = self.helper(node.left)
        right_min, right_min_sub, right_sum = self.helper(node.right)

        node_sum = left_sum + right_sum + node.val
        min_sum = min(left_min, right_min, node_sum)
        
        if min_sum == left_min:
            return left_min, left_min_sub, node_sum
        if min_sum == right_min:
            return right_min, right_min_sub, node_sum

        return node_sum, node, node_sum

```

###  4. 在实现中要注意的代码细节
递归的出口那里的第一个返回值，如果树只有一个节点，肯定是要返回这一个节点，因此空节点对应的最小值应该是最大数。


###  5. 时间空间复杂度
O(n)，一共有这么多子树，需要都遍历一遍




