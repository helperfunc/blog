# 概述
什么时候适用于用二分法解决问题呢？
* 从时间复杂度考虑，将 O(n) 变成 O(logn)
* 能提取出 oooxxx 的形式，每次缩小的范围都能包括解所出现的位置

注意点：
通过二分模板，写出没有死循环的代码。死循环出现的原因在于求 mid 时，除 2，取的是下界限。
如 [1,1], target=1，求最后一次 target 出现的位置，这时 mid 就一直会停留在 index = 0 处。
解决方法就是让循环终止的条件变成二分的范围[start, end]满足 start + 1 == end 时，即停止。

# 第一层境界：写出不会死循环的二分法
* http://www.lintcode.com/problem/classical-binary-search/
* http://www.lintcode.com/problem/first-position-of-target/
* http://www.lintcode.com/problem/last-position-of-targe
### 1. 用到了什么算法
二分法，直接套用模板
### 2. 看到什么条件想到的算法
有序数组，比 O(n) 的暴力解法要快。
### 3. 不同解法分别怎么做的
* 暴力解法，即遍历一遍数组，得到目标值的下标
* 二分时，每次排除一半不包括要找的值的区域，留下一半包括 target 的区域。
### 4. 在实现中要注意的代码细节
```python
def binarySplit(nums, target):
    # 边界判断
    if not nums:
        reuturn -1
    
    start, end = 0, len(nums) - 1
    # 当剩下两个元素时，就跳出循环
    while start + 1 < end:
        mid = start + (end - start) // 2
        if nums[mid] < target:
            start = mid
        elif nums[mid] == target:
            start = mid # classical binary search, last position of target
            #end = start # first position of target
        else:
            end = mid
    # classical binary search, first position of target
    if nums[start] == target:
        return start
    if nums[end] == target:
        return end
    '''
    # last position of target
    if nums[end] == target:
        return end
    if nums[start] == target:
        return end
    '''
    
    return -1
```
### 5. 时间空间复杂度
```
T(n) = T(n/2) + O(1)
     = T(n/4) + O(1) + O(1)
     = ...
     = T(1) + O(1) + ... + O(1)  # O(logn) 层，O(logn)个 O(1)
```
