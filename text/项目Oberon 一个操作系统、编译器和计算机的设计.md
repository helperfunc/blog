 **前言**

这本书展示了Oberon项目的结果，即设计并实现了一个现代工作站的整个软件环境。该项目由作者在1986年至1989年间承担，其主要目标是从零开始设计和实现一个可以被描述、解释和理解为整体的系统。为了实现这一目标，作者不仅构思了整个系统，而且编程实现了它。

选择一个合适的形式化语言至关重要，因此设计了Oberon语言，不仅作为一种有效的实现工具，而且作为一种出版物的媒介，就像Algol 60三十年前被创建时的精神一样。

由于其结构，Oberon语言同样适合展示编程系统的全局、模块化结构。

尽管Oberon系统在实现上投入的人年数不多，尽管它的紧凑性让其描述能够适应一本书的篇幅，但它并不是一个学术玩具，而是一个多功能的工作站系统，在学术界和工业界都找到了许多满意甚至热情的用户。这里描述的核心系统，包括存储、文件、显示、文本和查看器管理器、程序加载器和设备驱动程序，其主要力量来自于一个适当选择的、灵活的基本设施集合，以及它们在许多方向和许多应用中的有效扩展性。这种扩展性特别得益于Oberon语言，一方面，以及基本核心的效率，另一方面。它基于对象导向范式的应用，只要扩展性显得有利，就采用它。

除了核心系统外，我们还详细介绍了Oberon语言的编译器和图形系统，这两个都可以被视为应用程序。前者展示了如何设计一个紧凑的编译器，以实现快速编译和高效、密集的代码。后者作为一个基于对象导向技术的可扩展设计的例子，展示了如何与现有的文本系统集成。核心系统的另一个补充是一个网络模块，允许许多工作站相互连接。我们还展示了Oberon系统如何方便地作为多服务器站点的基础，容纳文件分发、打印和电子邮件服务。

紧凑性和规律结构，以及对重要细节高效实现的适当关注，似乎是经济软件工程的关键。通过Oberon系统，我们希望反驳Reiser定律，这一定律几乎被所有最近的操作系统发布所证实：尽管取得了巨大的进步，硬件的速度增长比软件变慢的速度慢得多。Oberon系统所需的人力只是构建广泛使用的商业操作系统所需的一小部分，以及它们对计算能力和存储容量需求的一小部分，同时为用户提供了相等的能力和灵活性，尽管没有某些花哨的功能。读者被邀请研究这是如何可能的。

但最重要的是，我们希望提供一个有价值的大型编程案例研究，供所有渴望从他人经验中学习的人受益。

我们感谢许多匿名贡献者的建议、建议和鼓励。特别感谢我们的同事H. Mössenböck和B. Sanders以及我们在Institut für Computersysteme的同事，他们阅读了这本书的草稿的所有或部分内容。我们感谢M. Brandis、R. Crelier、A. Disteli、M. Franz和J. Templ在将Oberon系统成功移植到各种商业可用计算机上的工作，从而使这本书对许多读者更有价值。我们感激我们的学校ETH为我们提供了环境和支持，使我们能够追求并完成这个项目。

苏黎世，1992年2月

N.W.和J.G.

---

**2013年版的前言**

关于准备这本书的第二版的计划，意见分歧很大。有些人认为这本书已经过时，没有人对这种类型的系统感兴趣了。“为什么要费心呢？”其他人则认为，需要这种类型的文字，它详细解释了整个系统，而不是仅仅提出策略和方法。“无论如何都要这样做！”

在过去的30年里，情况发生了很大的变化。但即使没有这些变化，提出和构建一个与现有全球“标准”竞争的系统，这将是荒谬的。实际上，很少有人会对使用它感兴趣。广大社区似乎陷入了这些巨大的软件系统中，对它们的复杂性、特殊性和偶尔的不可靠性感到无助。

但新的系统肯定会出现，可能是为了不同、有限的目的，允许更小的系统。人们在哪里学习他们的手艺呢？技术文献很少，我的结论是，理解通常是通过实践获得的，也就是说，“在工作中”。然而，这是一种繁琐且次优的学习方式。虽然科学是由原则和法则统治的，需要学习和理解，但在工程领域，经验是不可或缺的。计算机科学是否教授了几乎永远有效的法则？在任何其他工程领域中，它都注定要基于严格的数学原则。然而，它的核心几乎不是这样。相反，我们必须依赖经验，也就是说，通过研究良好的例子来学习。

Oberon项目的主要目的和推动力是提供一个单一的书籍，作为一个存在的系统的例子，实际上是在使用中，并在所有细节中得到解释。这项任务让我意识到，设计一个强大而可靠的系统很难，但更难的是让它如此简单和清晰，以至于它可以被研究和完全理解。最重要的是，它需要对什么是本质的严格集中，以及放弃其余部分的意愿，所有的流行“花哨”的东西。

最近，越来越多的人对设计新的、更小的系统感兴趣。流行的操作系统的复杂性不仅使它们难以理解，而且提供了“后门”的机会。它们允许外部代理在用户未注意到的情况下引入间谍和恶魔，使系统易于攻击和腐败。唯一的安全补救措施是从零开始构建一个安全的系统。

现在转向一个实际方面：1992年版的这本书最大的章节涉及将Oberon程序翻译成NS32032处理器的代码的编译器。现在这种处理器既不可获取，也不推荐其架构。我决定设计自己的处理器，以将对简单性和规律性的追求扩展到硬件上。这个决定的最终好处不仅是软件，而且Oberon系统的硬件也被完全和严格地描述。处理器被称为RISC。硬件模块仅用Verilog语言描述。

决定一个新的处理器加速了对编译器和链接加载器章节的完全重写。然而，这也提供了一个改进它们清晰度的可喜机会。新的处理器确实简化了整个编译器。

对于一个系统来说，为了使其可理解，关键元素是定义它的符号、形式或语言。50年前发布的Algol 60被提议作为一种出版物语言，作为一种形式，可以在不涉及特定计算机或任何机制的情况下定义算法。这是一个伟大的目标，但迄今为止几乎没有实现。

至少，Algol强调了通过具有数学严格基础的符号来实现抽象的重要性。至少，Algol是基于正式定义的语法的第一个语言。Algol是早期认识到程序永远不应该仅仅为了喂养计算机而编写，而应该始终为了被理解和教育人们而编写的结果。

在我过去的所有工作中，我一直试图设计Algol的继任者，以提高其严谨性，同时将其适用性从数值算法扩展到软件系统。从Algol开始，经过Pascal、Modula和Oberon，我们比以往任何时候都更接近这个目标，也比任何其他语言更接近。关键在于持续追求合理的简化。

Oberon语言在1988年定义，2007年进行了修订，主要是丢弃了重复或非本质的功能。除了处理器的更改，系统的源代码适应这个修订也是本书中许多本地更改的第二个重要原因。我们总结了各种删除功能的情况：

1. 丢弃了LONGINT、SHORTINT和LONGREAL数据类型，以及类型包含的概念。
2. 丢弃了LOOP和EXIT语句（具有多个退出点的重复项）。
3. 丢弃了WITH语句（区域类型保护）。
4. 丢弃了RETURN语句，并现在在函数过程声明的结尾处与结束合并。
