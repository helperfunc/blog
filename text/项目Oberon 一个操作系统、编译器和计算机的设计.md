**项目Oberon**
**一个操作系统、编译器和计算机的设计**
**修订版 2013**
**尼古劳斯·维尔特（Niklaus Wirth）和尤尔格·古特克内希特（Jürg Gutknecht）**
**ISBN 0-201-54428-8**

**前言**

这本书展示了Oberon项目的成果，即为现代工作站设计了一个完整的软件环境。这个项目是在1986-1989年间由作者们承担的，其主要目标是从零开始设计和实现一个完整的系统，并以一种可以被描述、解释和理解为整体的方式进行结构化。为了面对所有方面、问题、设计决策和细节，作者们不仅构思了整个系统，而且编程实现了它，以及更多内容。

尽管存在许多解释操作系统原理和结构的书籍，但实际实现并使用的系统描述却很少。我们不仅希望给出如何构建系统的建议，而且希望展示如何构建一个系统。程序列表因此在这个文本中扮演了关键角色，因为它们是唯一包含最终解释的内容。

选择一个合适的形式化语言因此变得非常重要，我们设计了Oberon语言，不仅作为一种有效的实现工具，而且作为一种发布算法的媒介，就像Algol 60三十年前被创建的精神一样。

由于其结构，Oberon语言同样适合展示编程系统的全局、模块化结构。

尽管实现Oberon系统所花费的人年数很少，尽管它的紧凑性使得它的描述能够适应一本书的篇幅，但它并不是一个学术玩具，而是一个多功能的工作站系统，在学术界和工业界找到了许多满意甚至热情的用户。这里描述的核心系统，包括存储、文件、显示、文本和查看器管理器，程序加载器和设备驱动程序，其主要力量来自于一个适当选择的、灵活的基本设施集合，以及它们在许多方向和许多应用中的有效可扩展性。可扩展性特别得到了Oberon语言的增强，一方面是基本核心的效率，另一方面是对象导向范式的应用，只要扩展性显得有利。

除了核心系统外，我们还详细介绍了Oberon语言的编译器和一个图形系统，这两者都可以被视为应用程序。前者展示了如何设计一个紧凑的编译器，以实现快速编译和高效、密集的代码。后者作为一个基于对象导向技术的可扩展设计的例子，展示了如何与现有的文本系统集成。核心系统的另一个补充是一个网络模块，允许许多工作站相互连接。我们还展示了Oberon系统如何方便地作为多服务器站的基础，容纳文件分发、打印和电子邮件设施。

紧凑性和规律结构，以及对重要细节高效实现的适当关注，似乎是经济软件工程的关键。通过Oberon系统，我们希望反驳Reiser定律，该定律几乎被所有最近的操作系统发布所证实：尽管取得了巨大的进步，硬件的速度增长比软件变得更慢。Oberon系统所需的人力只是构建广泛使用的商业操作系统所需的一小部分，而且对计算能力和存储容量的需求也只是一小部分，同时为用户提供了相等的能力和灵活性，尽管没有某些花哨的功能。读者被邀请研究这是如何可能的。

但最重要的是，我们希望提供一个有价值的大型编程案例研究，供所有渴望从他人经验中学习的人受益。

我们感谢许多匿名贡献者的建议、建议和鼓励。特别感谢我们的同事H. Mössenböck和B. Sanders以及我们在Institut für Computersysteme的同事们阅读了这本书的部分或全部草稿。我们感激M. Brandis、R. Crelier、A. Disteli、M. Franz和J. Templ在将Oberon系统成功移植到各种商用计算机上的工作，从而使这本书对许多读者更有价值。我们感谢学校ETH为我们提供了环境和支持，使我们能够追求并完成这个项目。

苏黎世，1992年2月
N.W.和J.G.

**2013年版前言**

关于准备这本书的第二版的计划，意见分歧很大。有些人认为这本书已经过时，没有人对这种类型的系统感兴趣了。“为什么要费心”？其他人则认为，有迫切需要这种类型的文字，它详细解释了整个系统，而不是仅仅提出策略和方法。“无论如何都要这样做”！

在过去的30年里，情况发生了很大的变化。但即使没有这些变化，提出和构建一个与现有全球“标准”竞争的系统，这将是荒谬的。实际上，很少有人会对使用它感兴趣。广大社区似乎陷入了这些巨大的软件系统中，对它们的复杂性、特殊性和偶尔的不可靠性感到无助。

但新的系统肯定会出现，可能是为了不同、有限的目的，允许更小的系统。人们在哪里学习他们的手艺？技术文献很少，我的结论是，理解通常是通过实践获得的，也就是说，“在工作中”。然而，这是一种繁琐和次优的学习方式。虽然科学是由原则和法律统治的，需要学习和理解，但在工程领域，经验是不可或缺的。计算机科学是否教授了几乎永远有效的法律？在任何其他工程领域中，它都注定要基于严格的数学原则。然而，它的核心几乎没有。相反，我们必须依赖经验，也就是说，通过研究良好的例子来学习。

Oberon项目的主要目的和推动力是提供一个单一的书籍，作为实际存在、正在使用并详细解释的系统的示例。这项任务让我意识到，设计一个强大而可靠的系统很难，但更难的是让它如此简单和清晰，以至于可以被学习和完全理解。最重要的是，它需要对什么是本质的严格集中，以及放弃其余部分，所有的流行“花哨”的东西。

最近，越来越多的人对设计新的、更小的系统感兴趣。流行的操作系统的复杂性不仅使它们难以理解，而且为“后门”提供了机会。它们允许外部代理在用户未注意到的情况下引入间谍和恶魔，使系统易于攻击和腐败。唯一的安全补救措施是从零开始构建一个安全的系统。

现在转向一个实际方面：1992年版的这本书最大的章节涉及将Oberon程序翻译成NS32032处理器的代码的编译器。这种处理器现在既不可用，也不推荐其架构。我没有写一个新的编译器来处理一些其他商业可用的架构，而是决定设计自己的，以便将对简单性和规律性的追求扩展到硬件上。这个决定的最终好处不仅是软件，而且Oberon系统的硬件也被完全和严格地描述。处理器被称为RISC。硬件模块仅用Verilog语言描述。

决定开发自己的处理器加速了对编译器和链接加载器章节的完全重写。然而，这也为我们提供了一个改进它们的清晰度的可喜机会。新的处理器确实简化了整个编译器。

对于一个系统来说，为了使其可理解，关键元素是定义它的符号、形式或语言。50年前发布的Algol 60被提议作为一种出版物语言，作为一种形式，可以在不涉及特定计算机或任何机制的情况下定义算法。这是一个伟大的目标，但迄今为止几乎没有实现。

至少，Algol强调了通过具有数学严格基础的符号来实现抽象的重要性。至少，Algol是基于正式定义的语法的第一个语言。Algol是早期认识到程序永远不应该仅仅为了喂养计算机而编写，而应该始终为了被理解和教育人们而编写的结果。

在我过去的所有工作中，我一直试图设计Algol的继任者，以提高其严谨性，同时将其适用性从数值算法扩展到软件系统。从Algol开始，经过Pascal、Modula和Oberon，我们比以往任何时候都更接近这个目标，也比任何其他语言更接近。关键在于持续追求合理的简化。

Oberon语言，定义于1988年，在2007年经历了一次修订，主要是丢弃了重复或非本质的功能。除了处理器的更改，系统的源代码适应这个修订是这次文本中许多本地更改的第二个重要原因。我们总结了各种删除功能的情况：

1. 丢弃了LONGINT、SHORTINT和LONGREAL数据类型，以及类型包含的概念。
2. 丢弃了LOOP和EXIT语句（具有多个退出点的重复项）。
3. 丢弃了WITH语句（区域类型保护）。
4. 丢弃了RETURN语句，并现在在结束函数过程声明时与结尾合并。
5. 在过程P中声明的对象在过程Q中不可访问，该过程本身是P的本地过程。也就是说，对象必须是严格本地的或全局的才能被访问。
6. 不允许对导入变量进行赋值（只读导出）。
7. 丢弃了前向过程声明。
8. 与这些删除相反，2012年添加了一个（单一）数据类型BYTE。它的值是满足0 ≤ x < 256的整数x。这个添加防止了频繁滥用类型CHAR。BYTE类型主要用于低级模块中的数组和记录元素，以节省内存使用。

尽管这些两个原因——最高级别的语言和最低级别的硬件——这本书的其余部分被证明相当稳定，并且仍然有效。它基本上保持了它在25年前的状态，没有修饰。我的愿望是展示系统基本上像它存在时那样，没有装饰。第3-5章关于任务、显示和文本，最初由J. Gutknecht编写，几乎没有变化。然而，主要在描述键盘和鼠标的设备驱动程序方面，需要进行重大更改。现在它们使用PS-2接口标准。磁盘已被单个SD卡（闪存）替换，具有标准的SPI接口。网络的接口不再使用RS-485接口，而是基于SPI标准。编译器和链接器的章节是全新的。

编译器和链接器的章节完全重写。主要由于RISC指令集的规律性，编译器的大小显著减小。现在它有不到2900行的程序，并且可以在大约3秒内编译自身，这证明了它的效率。整个系统可以在不到10秒内编译自身。几年前被认为是奢侈且几乎不必要的运行时检查现在自动生成。特别是，它们涵盖了索引范围检查和对NIL指针的访问。由于它们的效率，它们几乎不影响运行时速度，但对程序员来说是一个巨大的好处。

语言和处理器的简化带来的一个可喜后果是，所有在1992年版本中用汇编语言编写的部分——因此没有包含在书中——现在也用Oberon表达出来了。这证明了我长期以来努力获得一种既强大又灵活，同时足够高效以表达设备驱动程序和光栅操作等部分的高级语言的必要性和最终步骤，使这本书全面完整。

参考
http://www.inf.ethz.ch/personal/wirth/Oberon/Oberon07.Report.pdf
http://www.inf.ethz.ch/personal/wirth/FPGA-relatedWork/RISC.Arch.pdf

致谢
我非常感激Paul Reed的宝贵贡献。他设计了各种设备的接口，如PS-2和SPI，包括SD卡，作为磁盘存储。他提出了许多改进和简化建议。他最初果断地建议重新编辑这本书，30年前的书，并且是完成所有这些工作的关键推动力。我的感谢也送给他。

Niklaus Wirth，2013年9月

**Oberon项目**
**一个操作系统、编译器和计算机的设计**
**前言（1992年）**
**前言（2013年修订版）**
**1. 历史和动机**
**2. 系统的基本概念和结构**
**2.1. 介绍**
**2.2. 概念**
**2.2.1. 视图**
**2.2.2. 命令**
**2.2.3. 任务**
**2.2.4. 工具文本作为可配置菜单**
**2.2.5. 可扩展性**
**2.2.6. 动态加载**
**2.3. 系统的结构**
**2.4. 章节巡览**

**3. 任务系统**
**3.1. 任务的概念**
**3.1.1. 交互任务**
**3.1.2. 后台任务**
**3.2. 任务调度器**
**3.3. 命令的概念**
**3.3.1. 通用操作**
**3.3.2. 通用文本选择**
**3.3.3. 通用复制查看器**
**3.4. 工具箱**

**4. 显示系统**
**4.1. 屏幕布局模型**
**4.2. 视图作为对象**
**4.3. 帧作为基本显示实体**
**4.4. 显示管理**
**4.4.1. 视图**
**4.4.2. 菜单查看器**
**4.4.3. 光标管理**
**4.5. 光栅操作**
**4.6. 标准显示配置**

**5. 文本系统**
**5.1. 文本作为抽象数据类型**
**5.1.1. 加载和存储**
**5.1.2. 编辑文本**
**5.1.3. 访问文本**
**5.2. 文本管理**
**5.3. 文本框架**
**5.4. 字体机械**
**5.5. 编辑工具箱**

**6. 模块加载器**
**6.1. 链接和加载**
**6.2. 模块表示**
**6.3. 链接加载器**
**6.4. 加载器的工具箱**
**6.5. 对象文件格式**

**7. 文件系统**
**7.1. 文件**
**7.2. 随机访问存储上的文件实现**
**7.3. 磁盘上的文件实现**
**7.4. 文件目录**
**7.5. 文件实用程序的工具箱**

**8. 存储布局和管理**
**8.1. 存储布局和运行时组织**
**8.2. 动态存储管理**
**8.3. 内核**
**8.4. 存储管理的工具箱**

**9. 设备驱动程序**
**9.1. 概述**
**9.2. 键盘和鼠标**
**9.3. 串行外设接口（SPI）**
**9.4. 串行异步接口（RS 232）**

**10. 网络**
**10.1. 介绍**
**10.2. 协议**
**10.3. 站点寻址**
**10.4. 实现**

**11. 专用文件分发和邮件服务器**
**11.1. 概念和结构**
**11.2. 电子邮件服务**
**11.3. 打印服务**
**11.4. 杂项服务**
**11.5. 用户管理**

**12. 编译器**
**12.1. 介绍**
**12.2. 代码模式**
**12.3. 内部数据结构和模块接口**
**12.3.1. 数据结构**
**12.3.2. 模块接口**
**12.4. 解析器**
**12.5. 扫描器**
**12.6. 搜索符号表和处理符号文件**
**12.6.1. 符号表的结构**
**12.6.2. 符号文件**
**12.7. 代码生成器**
**12.7.1. 表达式**
**12.7.2. 关系**
**12.7.3. 集合操作**
**12.7.4. 赋值**
**12.7.5. 条件和重复语句**
**12.7.6. 布尔表达式**
**12.7.7. 过程**
**12.7.8. 类型扩展**
**12.7.9. 导入和导出，全局变量**
**12.7.10. 陷阱**

**13. 图形编辑器**
**13.1. 历史和目标**
**13.2. 简短的用户指南**
**13.2.1. 基本命令**
**13.2.2. 菜单命令**
**13.2.3. 更多命令**
**13.2.4. 宏**
**13.2.5. 矩形**
**13.2.6. 斜线和圆**
**13.2.7. 构建新宏**
**13.2.8. 构造新宏**
**13.3. 核心及其结构**
**13.4. 显示图形**
**13.5. 用户界面**
**13.6. 宏**
**13.7. 对象类**
**13.8. 实现**
**13.8.1. 模块Draw**
**13.8.2. 模块GraphicFrames**
**13.8.3. 模块Graphics**
**13.9. 矩形和曲线**
**13.9.1. 矩形**
**13.9.2. 斜线和圆**

**14. 构建和维护工具**
**14.1. 启动过程**
**14.2. 构建工具**
**14.3. 维护工具**

**15. 工具和服务模块**
**15.1. 基本数学函数**
**15.2. 数据链路**
**15.3. 图形宏生成器**

**16. RISC处理器的实现**
**16.1. 介绍**
**16.2. 算术和逻辑单元（ALU）**
**16.2.1. 移位器**
**16.2.2. 乘法**
**16.2.3. 除法**
**16.3. 浮点算术**
**16.3.1. 浮点加法**
**16.3.2. 浮点乘法**
**16.3.3. 浮点除法**

**16.4. 控制单元**

**17. 处理器环境**
**17.1. SRAM内存**
**17.2. 外围接口**
**17.2.1. PS-2接口**
**17.2.2. SPI接口**
**17.2.3. RS-232接口**
**17.2.4. 显示控制器**
**17.2.5. 鼠标接口**

**10 历史和动机**

在1985年的加利福尼亚度过的休假期间，我如何能够在阳光明媚的下午集中精力工作，这是一个修辞问题。在家里，每个人都会觉得有必要利用晴朗的间歇时间在乡村享受生活，漫步或从事自己喜欢的运动。但在这里，每一天都像这样，如果屈服于这种诱惑，就意味着工作的结束。而且，如果我不是因为这里宜人、愉快的气候而选择了这个位置，那将意味着什么？

幸运的是，我的工作也很吸引人，这使得我更容易投入到工作中。我有特权坐在可能是最先进的工作站前，学习计算机辅助设计的奥秘。这一切都必须在物理法则和最新技术规定的严格规则下进行。幸运的是，先进的计算机会立即抱怨如果违反了这样的规则，它就像你的大哥一样，防止你走向灾难。它做了自己不可能做到的事情，跟踪着成千上万的约束条件，这些约束条件分布在成千上万个矩形之间。这被称为计算机辅助设计。“辅助”是一个委婉的说法，但计算机并没有抱怨其角色的退化。

当我的眼睛紧紧盯着色彩斑斓的显示屏，面对着我最新的不足之处时，我的同事（JG）带着沮丧的表情走进了房间。他也在同一个实验室休假，但他的脸上并没有表现出快乐，而是沮丧。他手中的巧克力棒对他来说就像咖啡杯或烟斗对其他人一样，提供了暂时的放松和分心。这不是他第一次以这种情绪出现，我无需言语就能猜到其原因。而且这种情况会多次重复。

他的日子过得不像我那样充满乐趣的矩形推动；他被分配了设计相同先进计算机的编译器的任务。因此，他必须更密切地，甚至亲密地，处理底层软件系统。它的频繁失败必须被理解，因为他在编程，而我只是在通过应用程序使用它；简而言之，我是一个终端用户！这些失败必须被理解不是为了纠正的目的，而是为了找到避免它们的方法。如何获得必要的洞察力？我意识到我到目前为止一直回避这个问题；我对这个新系统的熟悉程度仅限于我手头任务的基本必需品。

很快，我意识到我几乎无法研究这个系统。它的规模简直令人敬畏，而且文档相应地稀疏。对紧迫问题的答案最好通过采访系统的设计者来获得，他们都是内部人员。在这样做的过程中，我们震惊地发现，我们经常无法理解他们的话语。解释充满了行话，并充满了对系统其他部分的引用，这些部分对我们来说同样神秘。

因此，我们从编译器构建和芯片设计中休息的休息时间被用来尝试识别系统新颖方面的实质，它与常规操作系统的区别在哪里？这些概念中哪些是必不可少的，哪些可以改进、简化甚至丢弃？它们扎根于哪里？系统的实质能否被提炼和提取，就像化学过程一样？

在随后的讨论中，我们的想法慢慢成形。突然，我们决定自己设计操作系统。“疯狂”是我的第一反应，“不可能”。工作的量看起来是压倒性的。毕竟，我们还得承担教学职责。但这个想法植入了我们的心中，并继续占据我们的头脑。

不久之后，家里发生的一些事件建议我应该接管关于系统软件的重要课程。由于这是不成文的规定，它应该主要处理操作系统原理，我犹豫了。我的顾虑很容易证明：毕竟，我从未设计过这样的系统，也没有它的任何部分。一个人怎么可能在没有第一手经验的情况下教授一门工程学科？

不可能？我们不是设计过编译器、操作系统和文档编辑器的小团队吗？而且，我不止一次地经历过，一个不充分和令人沮丧的程序可以从源代码的一小部分重新编程，这部分源代码是原始设计所用的。我们的思维风暴继续，有许多间歇，几个星期后，系统的某些形态慢慢从迷雾中浮现。一段时间后，做出了一个荒谬的决定：我们将从零开始设计我们的工作站的操作系统（恰好比用于我推动矩形的要弱得多）。

主要目标是亲自获得第一手经验，并全面理解每一个细节，这本质上决定了我们的人力：两个兼职程序员。我们试探性地将完成时间限制设定为三年。后来发现，这是一个好的估计；编程始于1986年初，第一个系统版本在1988年秋季发布。

虽然为项目选择一个合适的名称通常是一个小问题，通常留给机会和设计师的心血来潮，但这里可以回顾一下Oberon是如何进入我们的视野的。就在我们开始努力的时候，太空探测器Voyager因其拍摄的天王星及其卫星的壮观照片而成为头条新闻，其中最大的卫星名为Oberon。自从它发射以来，我一直认为Voyager项目是一个规划得非常好且成功的项目，作为对它的一个小致敬，我选择了它最新研究对象的名称。事实上，很少有工程项目的产品能够超出预期并超出它们的预期寿命；大多数项目在软件领域失败得更早。最后但并非最不重要，我们记得Oberon是精灵王的名字。

有意计划的人力短缺强制执行了一个健康的指导原则：专注于基本功能，省略仅仅迎合既定惯例和短暂口味的装饰。当然，首先必须识别和明确核心。当我们决定结果应该作为教学材料时，编程语言的选择就显得尤为重要。我们原本计划使用的Modula-2似乎并不完全令人满意。首先，它缺乏以适当的方式表达可扩展性的能力。而且，我们将可扩展性作为新系统的主要属性之一。通过“适当”，我们包括机器独立性。我们的程序应该以一种不涉及机器特定特征和低级编程设施的方式来表达，也许除了设备接口，那里的依赖是固有的。

因此，Modula-2通过现在被称为类型扩展的功能进行了扩展。我们还认识到，Modula-2包含几个我们不需要的功能，它们不会真正增强其表达能力，但同时增加了编译器的复杂性。但是编译器不仅必须实现，还必须描述、学习和理解。这导致了从清洁的板子开始在语言设计领域应用同样的原则：专注于本质，剔除其余部分。这个新的语言，仍然与Modula-2有很多相似之处，被赋予了与系统相同的名字：Oberon [1, 2]。与它的祖先相比，它更加简洁，最重要的是，它是朝着在不涉及机器特定特征的高水平上表达程序的重要一步。

我们从1985年晚秋开始设计系统，1986年初开始编程。作为工具，我们使用了我们的工作站Lilith和它的语言Modula-2。首先，开发了一个交叉编译器，然后是内部核心的模块以及必要的测试和下载设施。显示和文本系统的开发同时进行，当然，没有测试的可能性。我们学会了没有调试器，尤其是没有编译器，可以促进编程的谨慎。

随后，编译器被翻译成Oberon。这很快就完成了，因为原始版本是预期稍后翻译的。一旦它在目标计算机Ceres上可用，并且文本编辑设施可用，Lilith的脐带就可以切断了。Oberon系统已经实现了，至少是它的草稿版本。这发生在1987年中旬；它的描述随后发表[3]，手册和指南在1991年跟进[5]。

系统的完成又花了一年，集中在将工作站连接到网络进行文件传输[4]，建立中央打印设施，以及维护工具。在三年内完成系统的目标已经实现。系统在1988年中旬被介绍给更广泛的用户社区，并且可以开始应用程序的工作。开发了电子邮件服务，添加了图形系统，并进行了各种通用文档准备系统的开发。显示设施扩展到包括两个屏幕，包括颜色。同时，通过改进现有部分来吸收使用中的反馈。自1989年以来，Oberon已经在我们的初级编程课程中取代了Modula-2。

参考文献
1. N. Wirth. The programming language Oberon. Software - Practice and Experience 18, 7, (July 1988) 671-690.
2. M. Reiser and N. Wirth. Programming in Oberon - Steps beyond Pascal and Modula. Addison-Wesley, 1992.
3. N. Wirth and J. Gutknecht. The Oberon System. Software - Practice and Experience, 19, 9 (Sept. 1989), 857-893.
4. N. Wirth. Ceres-Net: A low-cost computer network. Software - Practice and Experience, 20, 1 (Jan. 1990), 13-24.
5. M. Reiser. The Oberon System - User Guide and Programmer's Manual. Addison-Wesley, 1991.


**2 系统的基本概念和结构**

**2.1. 介绍**

为了证明从头开始设计和构建整个操作系统的努力是值得的，需要一些基本的概念。我们首先讨论Oberon系统背后的主要概念和主导设计决策。在此基础上，我们将展示系统的结构。它将限制在其最粗略的层面，即最大构建块的组成和相互依赖性，即模块。本章以对本书其余部分的概述结束。它应该帮助读者理解在各个章节中描述的部分的角色、位置和重要性。

操作系统的基本目标是将计算机以某种抽象级别呈现给用户和程序员。例如，存储以可请求的变量或指定数据类型的变量的形式呈现，磁盘以字符序列（或字节）称为文件的形式呈现，显示以称为视图的矩形区域呈现，键盘以字符流的形式呈现，鼠标则以坐标对和一组键状态的形式呈现。每个抽象都通过某些属性进行特征描述，并受到底层计算机可用资源的约束。这通常被称为资源管理。

每个抽象本质上都隐藏了细节，即它抽象的细节。隐藏可能发生在不同的级别。例如，计算机可能允许根据其操作模式（用户/监管者模式）使存储的某些部分或某些设备变得不可达，或者编程语言可能通过其可见性规则固有的隐藏机制使某些部分不可达。后者当然更加灵活和强大，而前者在我们的系统中几乎可以忽略不计。隐藏之所以重要，是因为它允许保证某些抽象属性（称为不变性）的维护。抽象确实是任何模块化的关键，没有模块化，保证可靠性和正确性的所有希望都将消失。显然，Oberon系统是设计在基于目的导向抽象的基础上建立模块化结构。拥有适当的编程语言是一个不可或缺的先决条件，其重要性不能被过分强调。

2.2. 概念

2.2.1. 视图

随着用户与计算机之间交互的高互动性的出现，输入和输出设备的抽象变得重要。高互动性需要高带宽，而人类用户与高带宽的通道是眼睛。因此，计算机的视觉输出单元必须与人类眼睛适当匹配。这发生在20世纪70年代中期高分辨率显示器的出现，这又变得可能，因为更快、更便宜的电子存储组件。高分辨率显示器标志着计算机发展历史上为数不多的重大突破之一。现代显示器的典型带宽约为100 MHz。主要是高分辨率显示器使视觉输出成为抽象和资源管理的主题。在Oberon系统中，显示器被划分为视图，也称为窗口，或者更准确地说，是帧，屏幕（s）的矩形区域。一个视图通常由两个帧组成，一个包含主题名称和命令菜单的标题栏，以及一个包含一些文本、图形、图片或其他对象的主帧。一个视图本身是一个帧；帧原则上可以嵌套到任何深度。

系统提供了生成一个帧（视图）、移动和关闭它的例程。它在指定位置分配一个新的视图，并在请求时提供关于它可能的最佳位置的提示。它跟踪打开的视图集合。这被称为视图管理，与处理它们的显示内容相对。但是，高互动性不仅需要视觉输出的高带宽，还需要输入的灵活性。当然，不需要同样大的带宽，但键盘以大约100 Hz的速度限制打字速度是不够的。鼠标的出现在这方面取得了突破，它大约与高分辨率显示器同时出现。

这绝不是巧合。鼠标只有在适当的软件和高分辨率显示器的支持下才能充分发挥作用。它本身就是一个概念上非常简单的设备，在移动时发送信号。这些信号允许计算机更新显示上标记（光标）的位置。由于反馈通过人眼发生，因此鼠标不需要极高的精度。例如，当用户希望在屏幕上识别某个对象（如字母）时，他会移动鼠标，直到映射的光标到达对象。这与数字转换器形成鲜明对比，后者应该提供精确的坐标。Oberon系统非常依赖鼠标的可用性。

也许最聪明的主意是为鼠标配备按钮。通过能够用确定光标位置的同一只手发出请求信号，用户获得了发出位置相关请求的直接印象。通过软件实现位置依赖性，通过称为处理程序或解释器的本地于光标瞬间出现的视图区域的程序来解释信号。通过适当的软件，可以实现各种强大的命令激活技术。例如弹出菜单、下拉菜单等。在许多应用中，具有多个按键的鼠标远远优于只有单个按键的鼠标，Oberon系统基本上假设有三个按钮可用。当然，不同功能分配给按键可能会导致混淆，当每个应用程序规定不同的按键分配时。然而，通过坚持某些“全局”约定，可以很容易地避免这一点。在Oberon系统中，左键主要用于标记位置（设置插入点），中键用于发出一般命令（见下文），右键用于选择显示的对象。

最近，使用重叠窗口镜像堆叠在桌子上的文档变得流行。我们发现这种隐喻并不完全令人信服。部分隐藏的窗口通常在对它们的内容执行任何操作之前被带到顶部并完全可见。与此相比，实现这种方案所需的巨大努力是微不足道的。这是一个很好的例子，说明在成本与其收益不成比例的情况下，复杂性的收益是不相称的。因此，我们选择了一个实现起来简单得多，但与重叠窗口相比没有真正缺点的解决方案：如图2.1所示的平铺视图。

2.2.2. 命令

具有固定含义（对于每种类型的视图都是固定的）的位置相关命令必须通过固定含义的命令（对于每种类型的视图都是固定的）来补充。传统上，这种命令通过在特殊命令文本中键入要执行的程序的名称来在键盘上发出。在这方面，Oberon系统提供了一种新颖且更灵活的解决方案，下面将详细介绍。

首先，我们注意到，通常意义上的程序，即作为一个整体编译的文本，通常是作为命令的太大的单位，以服务于命令。例如，与通过鼠标命令插入一段文本相比。在Oberon中，行动的单位与编译单位的概念是分开的。前者是由（导出的）过程表示的命令，后者是模块。因此，一个模块可以定义多个命令，甚至通常是许多命令。这样的（通用）命令可以通过指向其在任何可见文本中的名称来随时调用，并通过点击中间鼠标按钮来实现。命令名称的形式为M.P，其中P是过程的标识符，M是声明P的模块的名称。因此，任何命令点击都可能导致加载一个或多个模块（如果M不在主存储中）。下一次调用M.P会立即发生，因为M已经加载。进一步的后果是，模块永远不会（自动）被移除，因为下一个命令可能也会引用相同的模块。

图2.1. Oberon显示带有平铺视图的显示

每个命令的目的都是为了改变某些操作数的状态。通常，它们由命令标识符后的文本表示，Oberon遵循这一惯例。严格来说，命令被表示为无参数的过程；但是，系统提供了一种方式，使得过程能够识别其起源文本的位置，从而读取并解释命令后的文本，即实际参数。读取和解释都必须明确编程。
参数文本必须引用在命令执行开始之前存在的对象，并且很可能是先前命令解释的结果。在大多数操作系统中，这些对象是注册在目录中的文件，它们充当命令之间的接口。Oberon系统扩展了这一概念；连续命令之间的链接不仅限制于文件，而且可以是任何全局变量，因为模块在命令终止后不会从存储中消失，如上所述。
这种巨大的灵活性似乎打开了潘多拉的盒子，确实如此，当被误用时。原因是全局变量的状态可能会完全确定并改变命令的效果。这些变量代表了隐藏的状态，隐藏在用户通常不知道它们的价值，也没有简单的方法来确定它们的价值。使用全局变量作为命令之间接口的Oberon编程风格的一条规则是避免隐藏状态，并减少引入全局变量。然而，我们并不将此规则提升到教条的地位。尽管变量没有可见部分，但确实存在真正有用的例外情况。
如何表示可见对象作为命令参数的问题仍然存在。一个明显的情况是使用最近选择作为参数。Oberon模块提供了一个用于定位该选择的程序（仅限于文本选择）。另一个可能性是使用光标位置在文本中。在插入新文本的情况下，这是使用的；键盘上的一个键被按下也被视为一个命令，它会导致字符在光标位置插入。
系统引入了一个特殊的设施来指定视图作为操作数：星号标记。当键盘的标记键（SETUP）被按下时，它会放置在光标位置。Oberon.MarkedViewer过程识别在其区域内的视图。通常在其后跟随星号的命令是将其作为参数的命令。命令中包含的文本内容，或者图形视图中的图形，或标记视图的任何其他部分，取决于命令过程的编程方式。
最后，不应忽略系统的一个非常受欢迎的特性。这是全局变量的持久性性质的直接后果，当命令失败时变得明显。检测到的故障导致陷阱。这种陷阱应被视为异常命令终止。在最坏的情况下，全局数据可能处于不一致的状态，但它们不会被丢失，并且可以基于它们的当前状态启动下一个命令。陷阱打开一个小视图，并列出调用过程的序列及其本地变量和当前值。这些信息帮助程序员确定陷阱的原因。

2.2.3. 任务

从上述介绍中可以得出，Oberon系统以其高度灵活的命令激活方案而区别于其他系统。命令的概念从插入单个字符和设置标记扩展到可能需要数小时或数天的计算。更重要的是，它通过虚拟不存在隐藏状态来区别于其他系统。系统的状态几乎完全由用户可见的内容决定。
这使得用户无需记住之前激活的命令、启动的程序、进入的模式等的长历史。在我们看来，模式是用户不友好系统的标志性特征。此时，应该已经很明显，系统允许用户同时进行几个不同的任务。它们以包含文本、图形或其他可显示对象的视图的形式表现出来。用户在选择下一个命令的运算数时隐式地切换任务。这个概念的特点是任务切换完全由用户显式控制，而原子操作单位是命令。
同时，我们将Oberon分类为单进程（或单线程）系统。这个明显的悖论应该如何理解？也许最好通过考虑基本的操作模式来解释。除非参与命令的解释，否则处理器处于一个循环中，不断轮询事件源。这个循环称为中央循环；它包含在模块Oberon中，可以被视为系统的心脏。两个固定的事件源是鼠标和键盘。如果检测到键盘事件，控制被分派到焦点视图的处理器，即持有光标的视图。如果检测到鼠标事件（键），控制被分派到光标当前所在的处理器。所有这些都在单个、不可中断的进程的范式下是可能的。
单进程的概念意味着不可中断性，因此命令不能与用户交互。交互仅限于命令执行前的命令选择。因此，典型的Oberon程序中不存在输入语句。输入是通过在命令调用之前指定和指定的参数提供的。
这个方案乍一看似乎是极其限制性的。实际上并非如此，如果考虑到单用户操作。正是这个单一的用户与计算机进行对话。人类可能有能力同时与几个进程进行对话，如果发出的命令非常耗时。我们建议，耗时的计算最好委托给松散耦合的计算服务器，在一个分布式系统中。
Oberon系统处理单个进程的主要优势在于任务切换仅在命令之间发生，而多进程系统中的切换可能在任何单个指令后被调用。显然，差异在于行动的粒度。Oberon的粒度是粗的，这对于单用户系统是完全可以接受的。
系统提供了在中央循环中插入进一步轮询命令的可能性。这是一个必要的例子，如果需要引入其他事件源。突出的例子是网络，其中命令可能从其他工作站发送。中央循环扫描所谓的任务描述符列表。每个描述符都指向一个命令过程。两个标准事件仅在它们的守卫允许的情况下被选择，即如果键盘输入存在，或者如果发生了鼠标事件。插入的任务必须在安装过程的开头提供自己的守卫。
网络插入命令，称为请求，引发了一个问题：如果请求到达时处理器正在执行另一个命令怎么办？显然，除非采取措施，否则请求将丢失。这个问题很容易通过缓冲输入来解决。这在每个输入设备驱动程序中都做了缓冲，包括键盘驱动程序和网络驱动程序。传入的信号触发中断，调用的中断处理程序接受输入并缓冲它。我们强调，这种中断处理仅限于驱动程序，即系统组件在最低级别。中断不会引发任务选择和任务切换。控制只是返回到中断点，中断对程序不可见。存在一个规则的例外：由于键盘输入的中止字符导致的中断会将控制返回到中央循环。

2.2.4. 作为可配置菜单的工具文本

当然，视图指定其自己的鼠标点击解释，命令可以从显示上的任何文本中调用，任何显示对象都可以作为命令之间接口的选择，以及命令作为无对话、不可中断的操作单位，这些Oberon概念的概念对Oberon编程风格以及使用计算机的方式产生了相当大的影响。通过选择、移动、复制和指定命令和命令参数，轻松灵活地选择文本片段，极大地减少了打字的需要。鼠标成为主要的输入设备：键盘仅用于输入文本数据。这通过所谓的工具文本的使用得到了强调，它们是经常使用的命令的组合，通常显示在视图器的较窄系统轨道上。人们通常不键入命令！它们已经可见了。通常，每个项目都有一个工具文本，供每个项目使用。工具文本可以被视为可单独配置的私人菜单。
键入命令的罕见性有一个非常愉快的副作用，即它们的名称可以是有意义的单词。例如，复制操作由Copy而不是cp表示，重命名由Rename而不是rn表示，调用文件目录摘录的调用名为Directory而不是ls。需要记忆无限列表的神秘缩写，这是用户不友好系统的另一个标志，消失了。
但是，Oberon概念的影响不仅限于计算机使用方式。它还扩展到了程序与环境通信的方式。系统核心中定义的抽象类型Text建议在许多情况下用文本替换文件作为输入和输出数据的载体。所获得的优势在于文本的即时可编辑性。例如，命令System.Directory的输出以显示文本的形式产生所需的文件目录摘录。可以将其部分或全部选择并使用常规编辑命令（鼠标点击）复制到其他文本中。或者，编译器接受文本作为输入。因此，可以在不将文本存储在磁盘上的情况下编译文本，执行程序，并对重新编辑的文本进行重新编译。
文本的无处不在的可编辑性以及全局数据（特别是视图）的持久性允许避免许多不促进实际追求任务进展的步骤。

2.2.5. 可扩展性

Oberon系统设计的一个重要目标是可扩展性。应该很容易通过添加利用现有资源的模块来扩展系统。同样重要的是，它也应该能够根据当前和实际使用的功能来减少系统。例如，处理不含图形的文档编辑器不应要求加载广泛的图形编辑器，作为独立系统的工作站不应要求加载广泛的网络软件，用于文员工作的系统不应包括编译器或汇编器。同样，引入新的显示框架的系统不应包括管理包含这些框架的视图的程序。相反，它 应该利用现有的视图管理。许多广泛使用的系统消耗大量内存空间，这是由于违反了工程学的基本规则。要求操作系统拥有数兆字节的存储空间，尽管通常被容忍，但这是荒谬的，也是用户不友好或可能是制造商友好的另一个标志。其原因不是别的，正是可扩展性的不足。

我们不仅将这种概念限制在过程可扩展性上，这是容易实现的。重要的是，扩展不仅可以添加更多的过程和功能，还可以引入基于系统提供的数据类型构建的自己的数据类型：数据可扩展性。例如，图形系统应该能够基于基本显示模块提供的框架，并通过扩展它们与图形属性来定义其图形框架。

这需要适当的语言特性。Oberon语言以类型扩展的形式提供了这种特性。如果没有类型扩展特性，我们会选择Modula-2。它对系统结构的影响是深远的，结果也非常令人鼓舞。与此同时，许多添加已经以惊人的轻松程度创建出来。其中之一在本书的末尾进行了描述。

基本系统在其资源需求方面仍然是相当谦虚的（参见第2.3节末尾的表格）。

2.2.6. 动态加载

激活不在存储中的模块中的命令意味着必须加载这些模块以及它们所有的导入。然而，调用加载器不仅仅限于命令激活；它也可能通过编程过程调用。这种特性对于实现真正的可扩展性是不可或缺的。模块必须按需加载。例如，文档编辑器在处理文档中的图形元素时加载图形包，但在其他情况下则不需要。

Oberon系统没有单独的链接器。模块在加载时与其导入一起链接，之前从不链接。因此，每个模块仅在主存储中（链接）和备份存储中（未链接，作为文件）存在一次。避免在不同的链接目标文件中生成多个副本是存储经济的关键。Oberon系统中不会出现预链接的兆字节文件，每个模块都是完全可重用的。

 2.3. 系统的结构

系统的最可识别的单位是其模块。因此，描述系统的结构以模块的术语是最合适的。由于它们的接口是明确声明的，因此也很容易以有向图的形式展示它们的相互依赖性。边缘表示导入。

Oberon系统的基本模块图是分层的，即没有循环。层次结构的最低成员实际上只导入硬件。这里指的是包含设备驱动程序的模块。但模块Kernel也属于这一类；它“导入内存”并包括磁盘驱动程序。层次结构顶部的模块实际上向用户导出。由于用户可以直接访问命令过程，因此这些顶层成员被称为命令模块或工具模块。

基本系统的核心层次结构如图2.2所示，直接导入和图形。为了简化图片，省略了直接导入边缘，如果存在从源到目标的间接路径。

模块名称的复数形式通常表示在模块中定义的抽象数据类型的导出。例如，Files、Modules、Fonts、Texts、Viewers、MenuViewers和TextFrames。以单数形式命名的模块通常表示模块管理的资源，无论是全局变量还是设备。变量或设备本身是隐藏的（未导出），并通过模块的导出过程变得可访问。例如，所有设备驱动程序、Input（键盘和鼠标）、Kernel（内存和磁盘）和Display。命令模块的名称大多根据它们主要代表的活动选择，如System模块和Edit模块。

Oberon模块，正如前面提到的，是系统的核心，包含中央循环，控制权在每个命令解释后返回，无论其正常终止还是异常终止。Oberon导出了几个辅助性质的过程，但主要是允许调用命令（Call）的过程和通过变量Oberon.Par访问命令的参数文本的过程。此外，它包含全局导出变量：日志文本。日志文本通常用于发出命令的提示和简短的失败报告。文本显示在模块System初始化时自动打开的日志查看器中。Oberon模块还包含两个用于在显示器上绘制和擦除的标记，鼠标光标和星指针。它导出用于绘制和擦除它们的程序，并允许安装不同模式的它们。

系统如图2.2所示基本上包含生成和编辑文本的设施，以及将它们存储在文件系统中。所有其他功能都由必须按需加载的模块执行。这包括，特别是，编译器、网络通信、文档编辑器和用户设计的程序。系统概念中对模块化、避免不必要的装饰和专注于核心的高度重视导致了系统异常紧凑。尽管这种特性在大型内存成本下降的时代可能被视为无关紧要，但我们认为它至关重要。我们只想提醒读者注意系统大小与其可靠性之间的相关性。此外，我们不认为仅仅因为资源便宜就奢侈地消耗它是一种良好的工程实践。以下表格列出了核心的模块和主要应用程序模块，指出了代码（以单词计）和静态变量（以字节计）的大小，以及源程序行数。

| 模块     | 代码 | 数据 | 行数 |
|----------|------|------|------|
| Kernel   | 1123 | 8244 | 263  |
| FileDir  | 1963 | 60   | 352  |
| Files    | 2360 | 148  | 505  |
| Modules  | 1214 | 112  | 226  |
| Input    | 186  | 32   | 79   |
| Fonts    | 628  | 56   | 115  |
| Display  | 1033 | 84   | 190  |
| Viewers  | 1324 | 104  | 206  |
| Texts    | 2906 | 204  | 537  |
| Oberon  | 1679 | 288  | 410  |
| MenuViewers | 1513 | 56 | 208 |
| TextFrames | 5786 | 292 | 874 |
| System   | 2134 | 72   | 418  |
| Edit     | 1096 | 1104 | 232  |
|          | 24945|10856|4615  |
| ORS     | 1762 | 992  | 319  |
| ORB     | 2348 | 408  | 437  |
| ORG     | 6699 | 34976 | 1125 |
| ORP     | 5994 | 144  | 974  |
|         | 16803 | 36520 | 2855 |
| 图形    | 3484 | 564  | 685  |
| GraphicFrames | 2832 | 288 | 498 |
| Draw     | 690  | 40   | 164  |
| Rectangles | 649  | 40   | 118  |
| 曲线    | 1765 | 72   | 241  |
|         | 9420 | 1004 | 1706 |

