# 0.总览
回归本质，宽度优先搜索是从一个点出发，用队列将该点周围的点，一层层遍历。

深度优先搜索，用到递归，会使用操作系统为栈分配的 8mb 的栈空间，栈空间会存函数中的参数，内部变量，返回值等，最多能调用的层级数，大概在10000左右，而

宽度优先搜索，用到队列，没有栈溢出的限制，所以**能够用 BFS 解决的问题，一定不要用 DFS 去做！**

宽度优先搜索因其层层遍历的特质，能解决以下三类问题：
* 连通块问题，找到连通的所有区域
* 分层遍历，图的层次遍历，简单图最短路径
* 拓扑排序，每次取出入度为 0 的点入队列

*补充*：面试中不考复杂图的最短路径。求最长路径的题目，如果图可以分层（第 i 层的节点只能走到第 i+1 层，不能走到 i-1 层），则能用 dp 解决，否则用 dfs 遍历，找到所有的路径。 

**建议**：Python 队列建议使用用 deque 不建议使用 Queue（涉及多线程加锁会更慢）

下面分别用一些题来巩固这几大宽搜考点。

# 1.连通块问题
通过一个点找到图中连通的所有点

图可能有环，需要用 hashset 保证每个点只被访问一次。

* https://www.lintcode.com/problem/clone-graph/
### 1. 用到了什么算法
宽度优先搜索
### 2. 看到什么条件想到的算法
遍历所有的节点，得到所有的节点
### 3. 不同解法分别怎么做的
还可以用 dfs 得到所有的节点，不过可以用 bfs 就不用 dfs
### 4. 在实现中要注意的代码细节
```python
"""
class UndirectedGraphNode:
     def __init__(self, x):
         self.label = x
         self.neighbors = []
"""

class Solution:
    """
    @param node: A undirected graph node
    @return: A undirected graph node
    """
    def cloneGraph(self, node):
        if node is None:
            return
        # 1. 找到所有的点
        nodes = self.findAllNodes(node)
        # 2. 拷贝所有的点，返回新旧节点的映射关系
        newOldNodesMap = self.copyAllNodes(nodes)
        # 3. 拷贝所有的边
        self.copyAllEdges(newOldNodesMap)
        # 4. 返回新图中对应旧节点的新节点
        return newOldNodesMap[node]
        
    def findAllNodes(self, node):
        # 宽度优先搜索
        queue = collections.deque([node])
        visited = set([node]) #当把点放到队列时，就标记
        while queue:
            curr_node = queue.popleft()
            for neighbor in curr_node.neighbors:
                if neighbor in visited:
                    continue
                visited.add(neighbor) #当把点放到队列时，就标记
                queue.append(neighbor)
        return list(visited)
    
    def copyAllNodes(self, nodes):
        newOldNodesMap = {}
        for node in nodes:
            new_node = UndirectedGraphNode(node.label)
            newOldNodesMap[node] = new_node
        return newOldNodesMap
        
    def copyAllEdges(self, newOldNodesMap):
        for oldnode, newnode in newOldNodesMap.items():
            for neighbor in oldnode.neighbors:
                newnode.neighbors.append(newOldNodesMap[neighbor])
```
### 5. 时间空间复杂度
时间复杂度 O(n+m) 其中 n 为 节点数，m 为边数。每个点看其所有的邻居，则一条边要被访问2次，dfs 的最内部的循环主体要执行 O(2m)=O(m)，最内层循环之外的那条语句`curr_node = queue.popleft()`的时间复杂度为 O(n)，则时间复杂度为 O(n+m)。不是 O(nm)，因为`for neighbor in curr_node.neighbors:` 不是所有边，只是一个节点的边。

空间复杂度 O(n+m)

* https://www.lintcode.com/problem/number-of-islands/
### 1. 用到了什么算法
在矩阵上的宽度优先搜索
每条边被两个点共享，一共有 RxC 个点，RxCx2 条边，矩阵上的 BFS 的时间复杂度为 O(RxC)
### 2. 看到什么条件想到的算法
连通性
### 3. 不同解法分别怎么做的

### 4. 在实现中要注意的代码细节

### 5. 时间空间复杂度


* https://www.lintcode.com/problem/knight-shortest-path/
### 1. 用到了什么算法

### 2. 看到什么条件想到的算法

### 3. 不同解法分别怎么做的

### 4. 在实现中要注意的代码细节

### 5. 时间空间复杂度

* 骑士拓展
* https://www.lintcode.com/problem/knight-shortest-path-ii/
```
Description

Given a knight in a chessboard n * m (a binary matrix with 0 as empty and 1 as barrier). the knight initialze position is (0, 0) and he wants to reach position (n - 1, m - 1), Knight can only be from left to right. Find the shortest path to the destination position, return the length of the route. Return -1 if knight can not reached.


Clarification

If the knight is at (x, y), he can get to the following positions in one step:

(x + 1, y + 2)
(x - 1, y + 2)
(x + 2, y + 1)
(x - 2, y + 1)

Example

Example 1:

Input:
[[0,0,0,0],[0,0,0,0],[0,0,0,0]]
Output:
3
Explanation:
[0,0]->[2,1]->[0,2]->[2,3]

Example 2:

Input:
[[0,1,0],[0,0,1],[0,0,0]]
Output:
-1


```
### 1. 用到了什么算法

### 2. 看到什么条件想到的算法

### 3. 不同解法分别怎么做的

### 4. 在实现中要注意的代码细节

### 5. 时间空间复杂度



* 朋友圈
* https://www.lintcode.com/problem/1179/

```
Description

There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.

Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.

1.1≤N≤200.
2.M[i][i] = 1 for all students.
3.If M[i][j] = 1, then M[j][i] = 1.


Example

Example 1:

Input: [[1,1,0],[1,1,0],[0,0,1]]
Output: 2
Explanation:
The 0th and 1st students are direct friends, so they are in a friend circle. 
The 2nd student himself is in a friend circle. So return 2.

Example 2:

Input: [[1,1,0],[1,1,1],[0,1,1]]
Output: 1
Explanation:
The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, 
so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.

```


### 1. 用到了什么算法

### 2. 看到什么条件想到的算法

### 3. 不同解法分别怎么做的

### 4. 在实现中要注意的代码细节

### 5. 时间空间复杂度

# 2.分层遍历
简单图最短路径

* https://www.lintcode.com/problem/word-ladder/

### 1. 用到了什么算法

### 2. 看到什么条件想到的算法

### 3. 不同解法分别怎么做的

### 4. 在实现中要注意的代码细节

### 5. 时间空间复杂度


# 3.拓扑排序

**几乎每个公司都有一道拓扑排序的面试题！**

## 求任意一个拓扑排序

* http://www.lintcode.com/problem/topological-sorting/

### 1. 用到了什么算法

### 2. 看到什么条件想到的算法

### 3. 不同解法分别怎么做的

### 4. 在实现中要注意的代码细节

### 5. 时间空间复杂度


## 判断是否存在拓扑排序

* 所有节点均能从图中被删除进入拓扑序

* http://www.lintcode.com/problem/course-schedule-ii/

### 1. 用到了什么算法

### 2. 看到什么条件想到的算法

### 3. 不同解法分别怎么做的

### 4. 在实现中要注意的代码细节

### 5. 时间空间复杂度

## 拓扑排序是否唯一

* 保持队列中有且仅有一个元素

* http://www.lintcode.com/problem/sequence-reconstruction/

### 1. 用到了什么算法

### 2. 看到什么条件想到的算法

### 3. 不同解法分别怎么做的

### 4. 在实现中要注意的代码细节

### 5. 时间空间复杂度


## 求字典序最小的拓扑排序

* http://www.lintcode.com/problem/alien-dictionary/

### 1. 用到了什么算法

### 2. 看到什么条件想到的算法

### 3. 不同解法分别怎么做的

### 4. 在实现中要注意的代码细节

### 5. 时间空间复杂度
