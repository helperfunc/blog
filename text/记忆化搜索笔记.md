

## O(n^2) 优化到 O(n)或者 O(nlogn)

### O(nlogn)

* n 次 O(logn) 操作，
   
   logn: BST，heap/segment tree/red-black tree
   
   
* logn 次的 O(n) 操作

   logn: 二分法。二分答案。O(n)调用判断函数所需的时间。
   
* 排序 + O(n)/O(nlogn)

   Two sum: 先排序 + O(n) 的 two pointers 算法。  
   
### O(n): 

* 双指针(merge two sorted array) 

* 单调栈、单调队列。

* n 次 O(1) 的操作

* 枚举法 

### O(1) 数据结构的操作

* 哈希表

* union find 并查集


动态规划要学好，要学会分题型。
